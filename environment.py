import numpy as np
from config import *
from utilities import *
from scipy.optimize import minimize
# Modeling the indoor environment, including temperature, humidity and carbon dioxide concentration.

class EnvironmentModel:
    def find_transpiration(self, T_air, Chi_air, LAI, CAC, PAR_flux, PPFD, r_a, r_s):
        # Function that finds the surface temperature through optimization and calculates the plant transpiration
        # returns the surface temperature, the evaporation rate E, the latent heat flux Î»E
        
        def energy_balance(surface_temperature, T_air, Chi_air, LAI, CAC, PAR_flux, PPFD, r_s,r_a, epsilon_vapor, Chi_air_sat, net_radiation):
            sensible_heat_flux = LAI*rho_a*c_specific_heat*(surface_temperature-T_air)/r_s
            latent_heat_flux = LAI*lambda_water*(Chi_air_sat+rho_a*c_specific_heat/lambda_water*epsilon_vapor*(surface_temperature-T_air)-Chi_air)/(r_s+r_a)
            
            return abs(net_radiation - sensible_heat_flux - latent_heat_flux)  # Objective is to minimize this to almost 0
        
         # Initial guess for surface temperature
        initial_guess = T_air
        # Use an optimization method to find the surface temperature that minimizes the energy balance equation
        epsilon_vapor = slope_of_saturation_vapor_pressure_curve(T_air)
        Chi_air_sat = saturated_vapor_concentration(T_air)
        net_radiation = net_radiation_equation(PAR_flux, CAC)
        args = (T_air, Chi_air, LAI, CAC, PAR_flux, PPFD, r_s,r_a,epsilon_vapor,Chi_air_sat, net_radiation)
        result = minimize(energy_balance, initial_guess, args, method='Nelder-Mead')

        # Check if the optimization was successful
        if not result.success:
            raise ValueError("Optimization failed to find a solution for surface temperature.")

        # Use the optimized surface temperature to calculate transpiration
        surface_temperature = result.x[0]
        E = LAI*(Chi_air_sat+rho_a*c_specific_heat/lambda_water*epsilon_vapor*(surface_temperature-T_air)-Chi_air)/(r_s+r_a)
        transpiration = E*lambda_water
        return surface_temperature, E, transpiration
    def temperature_ode(self, T_air, latent_heat_flux, T_out, PAR_flux, CAC):
        # Q_cov: Heat transfer via convection between the air and the outside environment, in Watts.
        Q_cov = alpha_cov*(T_air - T_out)
        
        # Q_trans: Heat transfer due to crop transpiration.
        # Q_trans = g_e*L*(Chi_crop - Chi_air) # J's implementation
        
        Q_trans = latent_heat_flux

        # Q_lamp: Heat generated by lamps.
        # Q_lamp = eta*P_E*f_on/100

        #Q_reflected = PAR_flux*rho_r*CAC

        
        return 0#(1/c_cap)*(-Q_cov-Q_trans) # + Q_lamp 
        # Gjermund included the Q_reflected. Is it correctly implemented? 

    def humidity_ode(self, Chi_air, Chi_out,E):
        return -0.2*Chi_air+0.2*Chi_out#+E
    
    def co2_ode(self):
        return 0

    def env_conditions(self, env_state, crop_state, climate, control_input):
        # State parameters
        T_air, Chi_air, CO2_air = env_state
        X_ns, X_s = crop_state
        LAI = biomass_to_LAI(X_s)
        CAC = LAI_to_CAC(LAI)
        # Varying parameters
        T_out, Chi_out, DAT = climate
        PAR_flux, PPFD, wind_vel = control_input

        # Calculated parameters
        r_s = stomatal_resistance_eq(PPFD)
        r_a = aerodynamical_resistance_eq(wind_vel, LAI)
        T_surface, E, latent_heat_flux = self.find_transpiration(T_air, Chi_air, LAI, CAC, PAR_flux, PPFD, r_a,r_s)

        dT_air_dt = self.temperature_ode(T_air, Chi_air, latent_heat_flux, T_out, PAR_flux)
        dChi_air_dt = self.humidity_ode(Chi_air, Chi_out, E)
        dCO2_air_dt = self.co2_ode()
        return np.array([dT_air_dt, dChi_air_dt, dCO2_air_dt])
